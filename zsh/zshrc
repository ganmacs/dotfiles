# -*- sh -*-

# ================
# General Settings
# ================

export LC_CTYPE=en_US.UTF-8
export LC_ALL=en_US.UTF-8
export LANG=en_US
export EDITOR=/usr/local/bin/vim

REPORTTIME=1                  # 自動的に消費時間の統計情報を表示する。

setopt auto_cd    # ディレクトリ名だけでcdする。
setopt no_tify    # バックグラウンドジョブが終了したらすぐに知らせる。
setopt no_beep    # 補完候補がないときなどにビープ音を鳴らさない。
setopt ignore_eof # ^Dでログアウトしないようにする。
setopt mark_dirs  # ファイル名の展開でディレクトリにマッチした場合末尾に / を付加する
setopt auto_list  # 曖昧な補完で、自動的に選択肢をリストアップ
setopt correct    # コマンドのスペルの訂正を使用する
setopt auto_remove_slash # 補完が/で終って、つぎが、語分割子か/かコマンドの後(;とか&)だったら、補完末尾の/を取る
setopt correct
setopt pushd_ignore_dups
setopt auto_pushd

# select word style
autoload -Uz select-word-style
select-word-style default
zstyle ':zle:*' word-chars " /=;@:{}.,|-_"
zstyle ':zle:*' word-style unspecified

# prompt
autoload -Uz vcs_info
autoload -Uz colors; colors
autoload -Uz is-at-least

setopt prompt_subst

zstyle ':vcs_info:*' enable git svn hg bzr
zstyle ':vcs_info:*' max-exports 3
zstyle ':vcs_info:*' check-for-changes true
zstyle ':vcs_info:*' stagedstr "+"
zstyle ':vcs_info:*' unstagedstr "*"
zstyle ':vcs_info:git:*' formats '[%b] %c%u'
zstyle ':vcs_info:git:*' actionformats '[%b|%a] %c%u'

function notify_precmd {
    prev_command_status=$?

    psvar=()
    LANG=en_US.UTF-8 vcs_info
    [[ -n "$vcs_info_msg_0_" ]] && psvar[1]="$vcs_info_msg_0_"

    if [[ "$TTYIDLE" -gt 8 ]]; then
        notify_title=$([ "$prev_command_status" -eq 0 ] && echo "Command succeeded \U1F646" || echo "Command failed \U1F645")
        osascript -e "display notification \"$prev_command\" with title \"$notify_title\""
    fi
}

function store_command {
    prev_command=$2
}

autoload -Uz add-zsh-hook
add-zsh-hook preexec store_command
add-zsh-hook precmd notify_precmd

PROMPT="%{${fg[green]}%}%n%{${reset_color}%}@%F{blue}localhost%f:%1(v|%F{red}%1v%f|) $ "

OK="✔ "
NG="✘ "
PROMPT_EXIT_STATUS="%(?.%F{green}$OK%f.%F{red}$NG%f) "
PROMPT_PATH="%F{blue}%~%f"

PROMPT="$PROMPT_EXIT_STATUS $PROMPT_PATH %1(v|%F{magenta}%1v%f|)
$ "

RPROMPT=" %F{yellow}[%*]"

# cdr

autoload -U cdr
zstyle ':chpwd:*' recent-dirs-max 100
zstyle ':filter-select' case-insensitive yes # 絞り込みをcase-insensitiveに

# =================
# 補完
# =================

setopt complete_in_word      # 語の途中でもカーソル位置で補完
setopt magic_equal_subst     # コマンドラインの引数で --prefix=/usr などの = 以降でも補完できる
setopt always_last_prompt    # カーソル位置は保持したままファイル名一覧を順次その場で表示
setopt auto_menu             # タブキーの連打で自動的にメニュー補完
setopt complete_in_word      # カーソル位置で補完する。

zstyle ':completion:*' list-colors 'di=34' 'ln=35' 'so=32' 'ex=31' 'bd=46;34' 'cd=43;34'
zstyle ':completion:*' list-colors ${(s.:.)LS_COLORS}
zstyle ':completion:*' format '%B%d%b'
zstyle ':completion:*' group-name ''
zstyle ':completion:*:default' menu select=2
zstyle ':completion:*:default' list-colors ""
# 大文字でも小文字でも補完する
zstyle ':completion:*' matcher-list 'm:{a-z}={A-Z}'
## 補完候補をキャッシュする。
zstyle ':completion:*' use-cache yes
## 詳細な情報を使う。
zstyle ':completion:*' verbose yes
## sudo時にはsudo用のパスも使う。
zstyle ':completion:sudo:*' environ PATH="$SUDO_PATH:$PATH"
# セパレータを設定する
zstyle ':completion:*' list-separator '-->'
zstyle ':completion:*:manuals' separate-sections true

# zsh-completions
fpath=(/usr/local/share/zsh-completions $fpath)
fpath+=~/.zfunc

autoload -U compinit; compinit

# ================
# History
# ================

HISTFILE=${HOME}/.zsh_history
HISTSIZE=10000000
SAVEHIST=10000000
HISTTIMEFORMAT="[%Y/%M/%D %H:%M:%S] "
setopt extended_history
setopt hist_ignore_dups   # 同じコマンドラインを連続で実行した場合はヒストリに登録しない。
setopt hist_ignore_space  # スペースで始まるコマンドラインはヒストリに追加しない。
setopt inc_append_history # すぐにヒストリファイルに追記する。
setopt share_history      # zshプロセス間でヒストリを共有する。
setopt no_flow_control    # C-s, C-qを無効にする
setopt hist_reduce_blanks # 履歴から無駄な空白を除く

#入力途中の履歴補完を有効化する
autoload history-search-end
zle -N history-beginning-search-backward-end history-search-end
zle -N history-beginning-search-forward-end history-search-end

#入力途中の履歴補完
bindkey "^P" history-beginning-search-backward-end
bindkey "^N" history-beginning-search-forward-end
bindkey '^R' history-incremental-pattern-search-backward

# ================
# alias
# ================

alias ls="ls -FG"
alias la="ls -FGThgoa"
alias l="ls -lFh"
alias rm="rm -i"
alias mv="mv -i"
alias be="bundle exec"
alias bs="bundle exec spring"
alias binit="bundle init; bundle install --path vendor/bundle"
alias emacs="open -a /Applications/Emacs.app/Contents/MacOS/Emacs"
alias ff='find . -name "*" | peco | xargs open'
alias fe='find . -name "*" | peco | xargs open -a emacs'
alias awk='gawk'
alias sed='gsed'
alias addx='chmod +x'
alias grep='ggrep'
alias tar='gtar'
alias vi='vim'
alias gibol='gibo -l | tr "\t" "\n" | sed "/^=/d" | sort | peco | xargs gibo'
alias git='hub'
alias g='hub'
alias p='pbpaste'
alias c='pbcopy'
alias e='open-alc'
alias dl='docker ps -l -q'
alias cmsgi='cmsg --no-merges | peco'
alias -g B='`git branch | peco | sed -e "s/^\*[ ]*//g"`'
alias -g prc='`ps aux | grep $1 | grep -v grep`'

# ======================
# source
# ======================

export PATH="/usr/local/bin:$PATH"

source `brew --prefix rbenv`/completions/rbenv.zsh
source `brew --prefix`/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh

export PATH="$HOME/.cabal/bin:$PATH"

# OPAM configuration
. $HOME/.opam/opam-init/init.zsh > /dev/null 2> /dev/null || true

export PATH="$HOME/src/github.com/ganmacs/dotfiles/bin:$PATH"

# Added by the Heroku Toolbelt
export PATH="/usr/local/heroku/bin:$PATH"

# peco and golang
export GOPATH=$HOME
export PATH=$PATH:$GOPATH/bin

# rust
source ~/.cargo/env
# llvm
export PATH=$PATH:/usr/local/opt/llvm/bin

if type docker >/dev/null 2>&1; then
    eval "$(direnv hook zsh)"
else
    echo "Please Install direnv"
fi

if type docker >/dev/null 2>&1; then
    eval "$(docker-machine env default)"
else
    echo "Please Install Docker"
fi

if type rbenv >/dev/null 2>&1; then
    eval "$(rbenv init -)"
else
    echo "Please Install rbenv"
fi

export PATH="/usr/local/heroku/bin:$PATH"

# ===============
# keybind
# ===============

# Emacs風キーバインド
bindkey -e
bindkey '^[h' backward-kill-word
bindkey '^h' backward-delete-char

function cdup() {
    echo
    cd ..
    zle reset-prompt
}
zle -N cdup
bindkey '^^' cdup

function open-alc() {
    url="http://eow.alc.co.jp/search?q="
    open "${url}$1"
}

function copy-line-as-kill() {
    zle kill-line
    if [[ -n ${CUTBUFFER} ]]; then
        echo -n "${CUTBUFFER}" | pbcopy
    fi
}
zle -N copy-line-as-kill
bindkey '^k' copy-line-as-kill

function clipboard-yank () {
    CUTBUFFER=$(pbpaste)
    zle yank
}
zle -N clipboard-yank
bindkey '^y' clipboard-yank

# peco
function peco-ghq() {
    local selected_dir=$(ghq list | peco --query "$LBUFFER")
    if [ -n "$selected_dir" ]; then
        BUFFER="cd ${GOPATH}/src/${selected_dir}"
        zle accept-line
    fi
    zle redisplay
}
zle -N peco-ghq
bindkey '^q' peco-ghq

function peco-branches() {
    local selected_branch="$(git branch | peco --query "$LBUFFER" | sed -e "s/^\*[ ]*//g")"
    if [ -n "$selected_branch" ]; then
        BUFFER="git checkout ${selected_branch}"
        zle accept-line
    fi
    zle redisplay
}
zle -N peco-branches
bindkey '^[g' peco-branches

function peco-find-file() {
    if git rev-parse 2> /dev/null; then
        source_files=$(git ls-files)
    else
        source_files=$(find . -type f)
    fi
    selected_files=$(echo $source_files | peco --prompt "[find file]")

    result=''
    for file in $selected_files; do
        result="${result}$(echo $file | tr '\n' ' ')"
    done

    BUFFER="${BUFFER}${result}"
    CURSOR=$#BUFFER
    zle redisplay
}
zle -N peco-find-file
bindkey '^s' peco-find-file

function peco-find-history() {
    BUFFER=$(fc -l -n -r 1 | peco )
    CURSOR=$#BUFFER
    zle redisplay
}
zle -N peco-find-history
bindkey '^r' peco-find-history

function run_tmux() {
    if [ -z "$TMUX" ]; then
        if tmux has-session >/dev/null 2>&1 ; then
            ret=$(tmux list-session | peco | sed -e "s/:.*//g")
            ret=$(echo ${ret} | sed -e "s/[\r\n]\+//g")
            if [ ! -z "$RET" ]; then
                tmux attach -t "$RET"
            fi
        fi
    fi
}

function reload() {
    source ~/.zshrc
}
